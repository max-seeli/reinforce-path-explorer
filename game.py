from argparse import ArgumentParser
import os

import numpy as np

from drawing import Container
from cell import CELL
from monte_carlo import MonteCarlo
from map import MapLoader

class Game(Container):

    def __init__(self, width, height, map_file):
        """
        Initialize the game. It is used to visualize the Monte Carlo algorithm.
        Click on a cell to see the episode generated by the agent.

        Parameters
        ----------
        width : int
            Width of the window.
        height : int
            Height of the window.
        map_file : str
            File to load the map.
        """
        self.window_dim = np.array([width, height])
        self.map_file = map_file

        super().__init__(self.window_dim[0], self.window_dim[1], frame_rate=20)

    def setup(self):  
        """
        Setup the game and the event bindings.
        """      
        self.grid = MapLoader.load_map(self.map_file)
        self.cell_size = self.window_dim / self.grid.shape
        self.goal = np.argwhere(self.grid == CELL.TARGET)[0]

        policy_filename = f"./policies/{os.path.basename(self.map_file).split('.')[0]}.policy.txt"
        policy_exists = os.path.exists(policy_filename)

        self.finder = MonteCarlo(self.grid, test_epsilon=0, policy_filename=policy_filename, load_policy=policy_exists)
        self.finder.monte_carlo_control()

        self.episode_length = np.zeros(self.grid.shape)
        for i in range(self.grid.shape[0]):
            for j in range(self.grid.shape[1]):
                start = (i, j)
                episode = self.finder.generate_episode(start)
                self.episode_length[i, j] = len(episode)   
         
        self.show_episode = False
        toggle_episode = lambda _: setattr(self, "show_episode", not self.show_episode)
        self.bind("<Button-1>", self.draw_episode)
        self.bind("<Button-3>", toggle_episode)

    def draw(self):
        """
        Draw the cells in the grid.
        """
        for i in range(self.grid.shape[0]):
            for j in range(self.grid.shape[1]):
                self.draw_cell(i, j)
                if self.show_episode:
                    self.draw_text(str(self.episode_length[i, j]), i, j)
                
        self.draw_grid(self.grid.shape[0], self.grid.shape[1], self.cell_size, color="black", linewidth=1.5)
        
    def draw_cell(self, i, j, color=None):
        """
        Draw a cell on the canvas.

        Parameters
        ----------
        i : int
            The x-coordinate of the cell.
        j : int
            The y-coordinate of the cell.
        color : str
            The color of the cell. If None, the color is determined by the cell type.
        """
        if color is None:
            color = self.grid[i][j].get_color()
        self.canvas.create_rectangle(i * self.cell_size[0], j * self.cell_size[1],
                                     (i + 1) * self.cell_size[0], (j + 1) * self.cell_size[1],
                                     fill=color, outline="")
        
    def draw_text(self, text, i, j, color="black"):
        """
        Draws text on a cell of the grid.
        
        Parameters
        ----------
        text : str
            The text to draw.
        i : int
            The x-coordinate of the cell.
        j : int
            The y-coordinate of the cell.
        color : str
            The color of the text.    
        """
        self.canvas.create_text(i * self.cell_size[0] + self.cell_size[0] / 2,
                                j * self.cell_size[1] + self.cell_size[1] / 2,
                                text=text, fill=color)

    def draw_episode(self, event):
        coords = np.array([event.x, event.y])
        i, j = np.clip(coords // self.cell_size, 0, np.array(self.grid.shape) - 1).astype(int)
        start = (i, j)
        episode = self.finder.generate_episode(start)

        def draw_path_segment(i, state):
            self.draw_cell(state[0], state[1], "orange")
            self.draw_text(str(i), state[0], state[1])
    
        for i, (state, _, _) in enumerate(episode):
            draw_path_segment(i, state)
        
        draw_path_segment(len(episode), self.goal)

        self.root.update()
        self.root.after(5000)      

    def is_valid_move(self, new_pos):
        """
        Check if the move is valid.

        Parameters
        ----------
        new_pos : tuple(int, int)
            The new position of the agent.

        Returns
        -------
        bool
            True if the move is valid, False otherwise.
        """
        return (0 <= new_pos[0] < self.grid.shape[0] and
                0 <= new_pos[1] < self.grid.shape[1] and
                self.grid[new_pos] != CELL.WALL)
    
    def is_won(self, new_pos):
        """
        Check if the game is won.
        
        Parameters
        ----------
        new_pos : tuple(int, int)
            The new position of the agent.

        Returns
        -------
        bool
            True if the game is won, False otherwise.
        """
        return self.grid[new_pos] == CELL.TARGET


if __name__ == "__main__":
    parser = ArgumentParser(description="Game")
    parser.add_argument("--width", type=int, default=500, help="Width of the window")
    parser.add_argument("--height", type=int, default=600, help="Height of the window")
    parser.add_argument("--map_file", type=str, default=os.path.join(os.getcwd(), "maps/map1.txt"), help="File to load the map")
    args = parser.parse_args()

    Game(args.width, args.height, args.map_file)
